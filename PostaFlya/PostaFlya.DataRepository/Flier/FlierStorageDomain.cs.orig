using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Linq.Expressions;
using System.Net;
using Microsoft.WindowsAzure.StorageClient;
using WebSite.Azure.Common.TableStorage;
using PostaFlya.Domain.Behaviour;
using PostaFlya.Domain.Content;
using PostaFlya.Domain.Flier;
using PostaFlya.Domain.Location;
using PostaFlya.Domain.Tag;
using WebSite.Infrastructure.Domain;
using WebSite.Infrastructure.Util;


namespace PostaFlya.DataRepository.Flier
{
    internal class FlierTableEntry : ExtendableTableEntry
        , StorageTableEntryInterface<FlierInterface>
        , HasPropertyGroupCollectionInterface
    {
        public string Id { get; set; }
        public int Version { get; set; }

        public string Title { get; set; }
        public string Description { get; set; }
        public string Tags { get; set; }
        public double LocationLatitude { get; set; }
        public double LocationLongitude { get; set; }
        public string LocationDescription { get; set; }
        public string Status { get; set; }
        public string FlierBehaviour { get; set; }

        public Guid? Image { get; set; }
        public string BrowserId { get; set; }
        public DateTime EffectiveDate { get; set; }
        public string WebsiteTags { get; set; }
<<<<<<< HEAD
        public byte[] ImageList { get; set; }
=======
        public DateTime? CreateDate { get; set; }
>>>>>>> a7d4508f9a772e5c65fb28c565236f362c988993


        public void Update(FlierInterface source)
        {
            Id = source.Id;
            Version = source.Version;
            Title = source.Title;
            Description = source.Description;
            Tags = source.Tags.ToString();

            Image = source.Image;
            BrowserId = source.BrowserId;
            EffectiveDate = source.EffectiveDate;
            CreateDate = source.CreateDate;

            LocationLatitude = source.Location.Latitude;
            LocationLongitude = source.Location.Longitude;
            LocationDescription = source.Location.Description;
            Status = source.Status.ToString();
            FlierBehaviour = source.FlierBehaviour.ToString();

            ImageList = SerializeUtil.ToByteArray(source.ImageList);
            

            _propertyGroupCollection = source.ExtendedProperties != null ? new PropertyGroupCollection(source.ExtendedProperties) : null;

#if DEBUG
            UpdateEntity(source);
#endif
        }

        public void UpdateEntity(FlierInterface target)
        {
            target.Title = Title;
            target.Description = Description;
            target.Tags = Tags == null ? new Tags() : new Tags(Tags);
            target.Location = new Location(LocationLongitude, LocationLatitude);
            target.Location.Description = LocationDescription;
            target.Image = Image;
            target.BrowserId = BrowserId;
            target.EffectiveDate = EffectiveDate;
            
            if(CreateDate.HasValue)
                target.CreateDate = CreateDate.Value;
            
            target.Id = Id;
            target.Version = Version;
            target.ImageList = SerializeUtil.FromByteArray<List<FlierImage>>(ImageList);

            var status = FlierStatus.Pending;
            Enum.TryParse(Status, true, out status);
            target.Status = status;

            var behaviour = Domain.Behaviour.FlierBehaviour.Default;
            Enum.TryParse(FlierBehaviour, true, out behaviour);
            target.FlierBehaviour = behaviour;

            target.ExtendedProperties = _propertyGroupCollection != null ? new PropertyGroupCollection(_propertyGroupCollection) : null;
        }

        private PropertyGroupCollection _propertyGroupCollection = new PropertyGroupCollection();
        public PropertyGroupCollection GetPropertyGroupCollection()
        {
            return _propertyGroupCollection;
        }
    }

    internal class FlierStorageDomain : StorageDomainEntityBase<FlierStorageDomain, FlierTableEntry, FlierInterface, Domain.Flier.Flier>
    {
        public static TableNameAndPartitionProvider<FlierInterface> 
            TableNamesAndPartition = new TableNameAndPartitionProvider<FlierInterface>()
                                    {
                                        {typeof(FlierTableEntry), IdPartition, "flierbyid", f => f.Id, f=>f.Id}, 
                                        {typeof(FlierTableEntry), BrowserPartition, "flierbyid", f => f.BrowserId, f=>f.Id}, 
                                        {typeof(FlierTableEntry), LocationPartition, "flierbyloc", f => GetLocationPartitionKey(f.Location), f=>f.Id}
                                    };

        public const int BrowserPartition = 1;
        public const int LocationPartition = 2;


        internal FlierStorageDomain(AzureTableContext tableContext)
            : base(TableNamesAndPartition, tableContext)
        {

        }

        internal FlierStorageDomain(FlierInterface flier, AzureTableContext tableContext)
            : this(tableContext)
        {
            this.DomainEntity.CopyFieldsFrom(flier);
            ClonedTable.CreateDefaultEntries();
        }

        public FlierStorageDomain() : base(TableNamesAndPartition)
        {

        }

        public ExtendableTableEntry GetTableStorage()
        {
            return ClonedTable.GetStorageTableEntries().FirstOrDefault(e => e != null) as ExtendableTableEntry;
        }

        public static IQueryable<FlierInterface> GetByBrowserId(string browserId, AzureTableContext tableContext)
        {
            var tableEntity =
                tableContext.PerformQuery<FlierTableEntry>(te => te.PartitionKey == browserId, BrowserPartition)
                    .AsEnumerable();

            return tableEntity
            .Select(ts => ts.CreateEntityCopy<Domain.Flier.Flier, FlierInterface>())
            .AsQueryable();
        }

        //what we'll do is provide enough field width to introduce extra
        //partitions when needed and we'll start with partitions of  111m? 0.001
        //and allow up to 1m 0.00001 http://en.wikipedia.org/wiki/Decimal_degrees
        internal static string GetLocationPartitionKey(Location loc)
        {
            //make positive and adjust to 0.001 precision
            //in future if we want to introduce smaller partitions
            //adjust the below to floor at a finer precision and the multiplier
            //below that accordingly
            //00000000-36000000 long
            //00000000-18000000 lat
            var longitudeAdjusted = (int)Math.Floor((loc.Longitude + 180.0) * 1000);
            var latitudeAdjusted = (int)Math.Floor((loc.Latitude + 90.0) * 1000);
            //take to 0.00001
            longitudeAdjusted *= 100;
            latitudeAdjusted *= 100;
            return longitudeAdjusted.ToString("D8") + ":" + latitudeAdjusted.ToString("D8");
        }

        public static IList<string> FindFliersByLocationTagsAndBoundingBox(Location location, Tags tags, BoundingBox boundingBox, AzureTableContext tableContext)
        {
            var partitionKeyMin = GetLocationPartitionKey(boundingBox.Min);
            var partitionKeyMax = GetLocationPartitionKey(boundingBox.Max);
//            var subPartitionKeyMin = partitionKeyMin.Substring(9);
//            var subPartitionKeyMax = partitionKeyMax.Substring(9);

            var watch = new Stopwatch();
            watch.Start();

            Expression<Func<FlierTableEntry, bool>> query =
                (fliers) => fliers.PartitionKey.CompareTo(partitionKeyMin) >= 0
                            && fliers.PartitionKey.CompareTo(partitionKeyMax) <= 0

                            // one day table storage will support this
                            //                          && fliers.PartitionKey.Substring(9).CompareTo(subPartitionKeyMin) >= 0
                            //                          && fliers.PartitionKey.Substring(9).CompareTo(subPartitionKeyMax) <= 0
                            //when it does can just remove the below checks as partition will be close enough
                            && fliers.LocationLongitude >= boundingBox.Min.Longitude
                            && fliers.LocationLongitude <= boundingBox.Max.Longitude
                            && fliers.LocationLatitude >= boundingBox.Min.Latitude
                            && fliers.LocationLatitude <= boundingBox.Max.Latitude;

//            Expression<Func<FlierTableEntry, MinType>> select =
//                ft => new MinType() { Id = ft.Id, ImageId = ft.Image, FlierBehaviour = ft.FlierBehaviour};

            var tableEntity = tableContext.PerformQuery(query, LocationPartition).AsEnumerable();

            var time = watch.ElapsedMilliseconds;
            Trace.TraceInformation("FindFliers time: {0}, numfliers {1}", time, tableEntity.Count());
            watch.Restart();
            var ret= tableEntity
                .Select(ts => ts.CreateEntityCopy<Domain.Flier.Flier, FlierInterface>())
                //.Select(ts => new Domain.Flier.Flier() { Id = ts.Id, Image = ts.ImageId, FlierBehaviour = (FlierBehaviour)Enum.Parse(typeof(FlierBehaviour), ts.FlierBehaviour) })
                .Where(_ => tags == null || !tags.Any() || _.Tags.IsSupersetOf(tags)).ToList()
                .AsQueryable();
            time = watch.ElapsedMilliseconds;
            Trace.TraceInformation("FindFliers transform time: {0}, numfliers {1}", time, tableEntity.Count());
            return ret.Select(f => f.Id).ToList();
        }
    }
}